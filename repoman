#!/bin/bash
#
# Repoman
# A tool to manage your Arch Linux repository
#
# Copyright (C) 2008-2010 Andrea Scarpino <andrea@archlinux.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

export TEXTDOMAIN='repoman'
export TEXTDOMAINDIR='/usr/share/locale'

colors(){
  if [ "${NOCOLOR}" != "true" ]; then
    DEFA="\033[1;0m"
    BOLD="\033[1;1m"
    LRED="\033[1;31m"
    LGRE="\033[1;32m"
    YELL="\033[1;33m"
  else
    NOCOLOR_FLAG=" --nocolor"
  fi
}

print_error(){
  printf "${LRED}$(gettext "error: ")${DEFA}${1}\n"
  exit 1
}

print_makepkg_error(){
  printf "${LRED}$(gettext "makepkg failed! Skip.\n")${DEFA}"
}

print_tar_error(){
  printf "${LRED}$(gettext "Extraction failed! Skip.\n")${DEFA}"
}

get_pkg_repo(){
    pkgrepo=`LC_ALL=C pacman -Si $1 2> /dev/null \
        | grep -m1 Repository | awk -F": " '{print $2}'`
    case $pkgrepo in
        core) ;;
        extra) ;;
        testing) ;;
        community) ;;
        community-testing) ;;
        *) pkgrepo="aur" ;;
    esac
}

extract_pkg(){
  if [ -f "${WORKSPACE}/pkgs/$1.tar.gz" ]; then
    if [ "${VERBOSE}" == "true" ]; then
      tar -xf "${WORKSPACE}/pkgs/$1.tar.gz" -C "${WORKSPACE}/pkgs" || print_tar_error $1
      printf "\n"
    else
      tar -xf "${WORKSPACE}/pkgs/$1.tar.gz" -C "${WORKSPACE}/pkgs" &> /dev/null || print_tar_error $1
    fi
  else
    printf "$(gettext "tarball not found. Skip\n")"
  fi
}

build_pkg(){
  local pkgname=${1}
  local packageinfo=`tar -tf "${WORKSPACE}/${REPO}.db.tar.gz" | grep -vE 'desc$|depends$' | sed -e 's:\/$::g' | grep '^'${pkgname}'-[0-9]$*'`
  [ ! -z ${packageinfo} ] && local repopkgver=$(echo ${packageinfo} | awk -F"-" '{print $(NF - 1)}')-$(echo ${packageinfo} | awk -F"-" '{print $NF}')

  printf "${LGRE}${pkgname}${DEFA}\n"
  [ ${EDIT} ] && edit_pkgbuild ${pkgname}

  cd ${WORKSPACE}/pkgs/${pkgname}
  source PKGBUILD
  packagever=${pkgver}-${pkgrel}

  if [ $(vercmp ${packagever} ${repopkgver}) -gt 0 -o "$FORCE" == "true" ]; then
    if [ "${arch[0]}" == "any" ]; then
      arch="any"
    else
      arch="${CARCH}"
    fi
    if [ ! -f ${WORKSPACE}/${pkgname}-${packagever}-${arch}${PKGEXT} -o "$NOBUILD" != "true" ]; then
      if [ "${VERBOSE}" == "true" ]; then
        makepkg -f --noconfirm $ROOT_FLAG $NOCOLOR_FLAG || print_error "makepkg failed"
        printf "\n"
      else
        makepkg -f --noconfirm $ROOT_FLAG $NOCOLOR_FLAG &> /dev/null || print_error "makepkg failed"
      fi

      source PKGBUILD
      packagever=${pkgver}-${pkgrel}
      if [ -f ${WORKSPACE}/pkgs/${pkgname}/${pkgname}-${packagever}-${arch}${PKGEXT} ]; then
        cp ${WORKSPACE}/pkgs/${pkgname}/${pkgname}-${packagever}-${arch}${PKGEXT} ${WORKSPACE}/
        built="${built} ${pkgname}-${packagever}-${arch}${PKGEXT}"
      else
       print_error "error"
      fi
    else
      printf "${LGRE}$(gettext "done, already built")${DEFA}\n"
      built="${built} ${pkgname}-${packagever}-${arch}${PKGEXT}"
    fi
  else
    printf "${YELL}$(gettext "skip, already up-to-date")${DEFA}\n"
  fi
}

update(){
  printf "$(gettext "Updating changelog...\n")"
  if [ "${NOCHANGELOG}" != "true" ]; then
    [ -f /tmp/${basename} ] && rm -rf /tmp/${basename}
    mkdir /tmp/${basename}
    if [ "${ADD}" == "true" ]; then
      for pkg in ${built}; do
        echo "* `date +\"%d-%m-%Y %R\"` `whoami` ${pkg}" >> /tmp/${basename}/header
      done
    fi
    if [ "${REMOVE}" == "true" ]; then
      for pkg in ${packages}; do
        echo "* `date +\"%d-%m-%Y %R\"` `whoami` ${pkg} REMOVED" >> /tmp/${basename}/header
      done
    fi
    cat /tmp/${basename}/header "${WORKSPACE}/${CHANGELOG}" > "/tmp/${basename}/${CHANGELOG}"
    mv "/tmp/${basename}/${CHANGELOG}" "${WORKSPACE}/${CHANGELOG}"
  fi
    
  if [ "${ADD}" == "true" ]; then
    printf "$(gettext "Adding packages to repository...\n")"
    pushd "${WORKSPACE}" &> /dev/null
    if [ "${VERBOSE}" == "true" ]; then
       repo-add "${REPO}.db.tar.gz" ${built} || print_error "repo-add error"
    else
      repo-add "${REPO}.db.tar.gz" ${built} &> /dev/null || print_error "repo-add error"
    fi
    popd &> /dev/null
  elif [ "${REMOVE}" == "true" ]; then
    printf "$(gettext "Removing packages from repository...\n")"
     if [ "${VERBOSE}" == "true" ]; then
      repo-remove "${WORKSPACE}/${REPO}.db.tar.gz" ${packages} || print_error "repo-remove error"
    else
      repo-remove "${WORKSPACE}/${REPO}.db.tar.gz" ${packages} &> /dev/null || print_error "repo-remove error"
    fi
  fi
}

usage(){
  printf "$(gettext "A tool to manage your personal Arch Linux repository\n")"
  printf "$(gettext "Usage: ${basename} <action>|<flag> [OPTIONS] packages\n")"
  printf "\n"
  printf "$(gettext "Action:\n")"
  printf "$(gettext "  -S, --add <pkg>    add or update packages on repository\n")"
  printf "$(gettext "  -R, --remove <pkg> remove packages from repository\n")"
  printf "$(gettext "      --create <pkg> create a new database, then add packages\n")"
  printf "$(gettext "Flag:\n")"
  printf "$(gettext "      --all          update the whole repository\n")"
  printf "$(gettext "      --devel        rebuild only devel packages on repository\n")"
  printf "$(gettext "Options:\n")"
  printf "$(gettext "  -f, --force        build packages if already up-to-date on repo\n")"
  printf "$(gettext "  -k, --keep         do not get tarballs from AUR, use local in pkgs/\n")"
  printf "$(gettext "  -u, --noupload     do not upload any file to ftp\n")"
  printf "$(gettext "  -b, --nobuild      do not build packages if exist in workspace dir\n")"
  printf "$(gettext "      --nochangelog  do not use a changelog file\n")"
  printf "$(gettext "      --noconfirm    do not ask\n")"
  printf "$(gettext "      --noedit       do not ask to edit pkgbuild for each package\n")"
  printf "$(gettext "      --keepsrc      backup/restore for the local sources (src)\n")"
  printf "$(gettext "      --clean        remove any files from workspace dir\n")"
  printf "$(gettext "      --nocolor      do not use any color\n")"
  printf "$(gettext "  -v, --verbose      more verbose, print commands output\n")"
  printf "$(gettext "      --help         display this help and exit\n")"
}

check_args(){
  ADD="false"
  REMOVE="false"
  CREATE="false"
  ALL="false"
  DEVEL="false"
  FORCE="false"
  KEEP="false"
  KEEPSRC="false"
  NOUPLOAD="false"
  NOBUILD="false"
  NOCHANGELOG="false"
  NOCOLOR="false"
  NOCONFIRM="false"
  EDIT="true"
  VERBOSE="false"
  
  if [ -f ${HOME}/.repoman.conf ]; then
    source "${HOME}/.repoman.conf"
  else
    source "/etc/repoman.conf"
  fi
  source /etc/makepkg.conf
  [ -f ${HOME}/.makepkg.conf ] && source ${HOME}/.makepkg.conf
  
  if [ "$#" -eq "0" ]; then
    usage
    exit 1
  fi

  while [ "$#" -ne "0" ]; do
    OPTIND=0
    for EXTRA_FLAG in $@; do
      case $EXTRA_FLAG in
        -*) break ;;
         *) packages="${packages} ${EXTRA_FLAG}"; shift ;;
      esac
    done
    while getopts ":RSbfkuvv:-:" ARGS; do
      case $ARGS in
        R) REMOVE="true";;
        S) ADD="true" ;;
        b) NOBUILD="true" ;;
        f) FORCE="true" ;;
        k) KEEP="true" ;;
        u) NOUPLOAD="true" ;;
        v) VERBOSE="true" ;;
        -) 
        case $OPTARG in
          add) ADD="true" ;;
          remove) REMOVE="true";;
          create) CREATE="true"; ADD="true" ;;
          all) ALL="true"; ADD="true" ;;
          devel) DEVEL="true"; ADD="true"; FORCE="true" ;;
          force) FORCE="true" ;;
          keep) KEEP="true" ;;
          keepsrc) KEEPSRC="true" ;;
          noupload) NOUPLOAD="true" ;;
          nobuild) NOBUILD="true" ;;
          nochangelog) NOCHANGELOG="true" ;;
          nocolor) NOCOLOR="true" ;;
          noconfirm) NOCONFIRM="true" ;;
          edit) EDIT="false" ;;
          verbose) VERBOSE="true" ;;
          clean) clean; exit 0 ;;
          help) usage; exit 0 ;;
          *) usage; exit 1 ;;
        esac ;;
        ?) usage; exit 1 ;;
      esac
    done
    shift $(($OPTIND - 1))
  done
}

edit_pkgbuild(){
  if [ -f "${WORKSPACE}/pkgs/$1/PKGBUILD" ]; then
    printf "${BOLD}$(gettext "Do you want to edit %s PKGBUILD? (Y/n): ")${DEFA}" "$1"
    read EDIT_ANSWER
    if [ "$EDIT_ANSWER" != "$(gettext "n")" ]; then
      [ -z "$EDITOR" ] && EDITOR="nano"
      $EDITOR "${WORKSPACE}/pkgs/$1/PKGBUILD"
    fi
  fi
}

get_pkg_from_aur(){
  if [ "${VERBOSE}" == "true" ]; then
    wget -P "${WORKSPACE}/pkgs" http://aur.archlinux.org/packages/$1/$1.tar.gz || print_error "$(gettext "cannot download %s") $1"
    printf "\n"
  else
    wget -P "${WORKSPACE}/pkgs" http://aur.archlinux.org/packages/$1/$1.tar.gz &> /dev/null || print_error "$(gettext "cannot download %s") $1"
  fi
}

get_pkgbuild(){
  if [ "${KEEP}" != "true" ]; then
    if [ "${KEEPSRC}" == "true" ]; then
      rm -rf ${WORKSPACE}/pkgs/$1/{pkg/,${1}*} &> /dev/null
    else
      rm -rf ${WORKSPACE}/pkgs/$1{,.tar.gz} &> /dev/null
    fi
    get_pkg_repo $1
    if [ "${pkgrepo}" != "aur" ]; then
      if [ "${VERBOSE}" == "true" ]; then
        rsync -mrtv --no-motd --delete-after --delete-excluded rsync.archlinux.org::abs/`uname -m`/${pkgrepo}/$1 "${WORKSPACE}/pkgs"
        printf "\n"
      else
        rsync -mrtv --no-motd --delete-after --delete-excluded rsync.archlinux.org::abs/`uname -m`/${pkgrepo}/$1 "${WORKSPACE}/pkgs" &> /dev/null
      fi
    elif [ "${pkgrepo}" == "aur" ]; then
      get_pkg_from_aur $1
      extract_pkg $1
    fi
  elif [ -f "${WORKSPACE}/pkgs/$1/PKGBUILD" ]; then
    printf "$(gettext "(keep PKGBUILD)\n")"
  else
    printf "$(gettext "PKGBUILD not found. Skip\n")"
  fi
}

ask_remove(){
  printf "${BOLD}$(gettext "Do you want to clean packages build dirs? (y/N): ")${DEFA}"
  read DIR_REMOVE
  if [ "$DIR_REMOVE" == "y" ]; then
    rm -rf ${WORKSPACE}/pkgs/*/{pkg,src,*.pkg.tar.*}
  fi
}

clean(){
  rm -rf "${WORKSPACE}" /tmp/${basename} &> /dev/null
  printf "${BOLD}$(gettext "Any files in workspace directory have been removed!\n")${DEFA}"
}

remove_from_ftp(){
  printf "Cleanup ftp..."
  files=""
  for pkg in ${packages}; do
    local packageinfo=`tar -tf "${WORKSPACE}/${REPO}.db.tar.gz.old" | grep -vE 'desc$|depends$' | sed -e 's:\/$::g' | grep '^'${pkg}'-[0-9]$*'`
    files="${files} ${packageinfo}-*.pkg.tar.*"
  done
  if [ "${VERBOSE}" == "true" ]; then
    lftp -u "${USERNAME},${PASSWORD}" -e "${LFTP_CMDS}; glob rm -f ${files}; exit" "${FTP_URL}/${FTP_DIR}"
    printf "\n"
  else
    lftp -u "${USERNAME},${PASSWORD}" -e "${LFTP_CMDS}; glob rm -f ${files}; exit" &> /dev/null "${FTP_URL}/${FTP_DIR}"
  fi
}

upload(){
  printf "Uploading files..."
  
  files="${REPO}.db.tar.gz"
  [ ! ${NOCHANGELOG} ] && files="${files} ${CHANGELOG}"
    
  if [ "${ADD}" == "true" ]; then
    for pkg in ${built}; do
      files="${files} ${pkg}"
    done
  fi
  pushd ${WORKSPACE} &> /dev/null
  if [ "${VERBOSE}" == "true" ]; then
    lftp -u ${USERNAME},"${PASSWORD}" -e "${LFTP_CMDS}; put ${files}; exit" "${FTP_URL}/${FTP_DIR}" || print_error "$(gettext "upload failed")"
  else
    lftp -u ${USERNAME},"${PASSWORD}" -e "${LFTP_CMDS}; put ${files}; exit" "${FTP_URL}/${FTP_DIR}" &> /dev/null || print_error "$(gettext "upload failed")"
  fi
  popd &> /dev/null
  printf "${LGRE}done${DEFA}\n"
}

get_pkgs_list(){
  for package in `tar -tf "${WORKSPACE}/${REPO}.db.tar.gz" | grep -vE 'desc$|depends$' | sed -e 's:\/$::g'`; do
    local pkgname=$(echo ${package} | awk -F"-" '{for (i=1; i<NF - 2; i++) printf "%s-", $i; printf "$(NF - 2)\n" }')
    local pkgver=$(echo ${package} | awk -F"-" '{print $(NF - 1)}')
    local pkgrel=$(echo ${package} | awk -F"-" '{print $NF}')
  done
}

check_files(){
  if [ ! -d "${WORKSPACE}/pkgs" ]; then
    mkdir -p "${WORKSPACE}/pkgs" || exit 1
  fi
  if [ "${NOCHANGELOG}" != "true" -a ! -f "${WORKSPACE}/${CHANGELOG}" ]; then
    touch "${WORKSPACE}/${CHANGELOG}" || exit 1
  fi
}

main(){
  
  [ "$UID" -eq 0 ] && ROOT_FLAG=" --asroot"

  check_args $@
  check_files
  colors

  if [ "${CREATE}" != "true" ]; then
   if [ "${NOCHANGELOG}" != "true" ]; then
      printf "${YELL}$(gettext "Downloading") ${DEFA}${CHANGELOG}\n"
      mv "${WORKSPACE}/${CHANGELOG}" "${WORKSPACE}/${CHANGELOG}.old" &> /dev/null
      if [ "${VERBOSE}" == "true" ]; then
        wget -P "${WORKSPACE}" "${URL}/${CHANGELOG}" || print_error "$(gettext "unable to get %s") ${CHANGELOG}"
      else
        wget -P "${WORKSPACE}" "${URL}/${CHANGELOG}" &> /dev/null || print_error "$(gettext "unable to get %s") ${CHANGELOG}"
      fi
    fi
    printf "${YELL}$(gettext "Downloading") ${DEFA}${REPO}.db.tar.gz\n"
    mv "${WORKSPACE}/${REPO}.db.tar.gz" "${WORKSPACE}/${REPO}.db.tar.gz.old" &> /dev/null
    if [ "${VERBOSE}" == "true" ]; then
      wget -P "${WORKSPACE}" "${URL}/${REPO}.db.tar.gz" || print_error "$(gettext "unable to get %s") ${REPO}.db.tar.gz"
    else
      wget -P "${WORKSPACE}" "${URL}/${REPO}.db.tar.gz" &> /dev/null || print_error "$(gettext "unable to get %s") ${REPO}.db.tar.gz"
    fi
  fi

  [ "${ALL}" == "true" -o "${DEVEL}" == "true" ] && get_pkgs_list

  if [ ! -z ${packages} ]; then
    printf "${YELL}$(gettext "Packages: %s")${packages}${DEFA}\n"
  else
    printf "$(gettext "None package.\n\n")"
    exit 0
  fi

  if [ "${ADD}" != "true" -a "${REMOVE}" != "true" ]; then
    printf "$(gettext "What I must do with these packages?!\n\n")"
    exit 0
  fi

  if [ "${ADD}" == "true" ]; then
    printf "${YELL}$(gettext "Getting PKGBUILDs...")${DEFA}"
    for pkg in ${packages}; do
      get_pkgbuild ${pkg}
    done
    printf "\n"
    
    printf "${YELL}$(gettext "Building: ")${DEFA}"
    for pkg in ${packages}; do
        build_pkg ${pkg}
    done
  fi
  
  if [ ! -z ${built} ] || [ "${REMOVE}" == "true" ]; then
    update
    [ "${NOUPLOAD}" != "true" ] && upload
    [ "${REMOVE}" == "true" ] && remove_from_ftp

    if [ ${NOCONFIRM} != "true" ]; then
      [ "${ADD}" == "true" ] && ask_remove
    fi
  fi
}

main $@

exit 0
