#!/bin/bash
#
# Repoman
# A tool to manage your Arch Linux repository
#
# Copyright (C) 2008-2010 Andrea Scarpino <andrea@archlinux.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

export TEXTDOMAIN='repoman'
export TEXTDOMAINDIR='/usr/share/locale'

colors(){
  if [ "${NOCOLOR}" != "true" ]; then
    DEFA="\033[1;0m"
    BOLD="\033[1;1m"
    LRED="\033[1;31m"
    LGRE="\033[1;32m"
    YELL="\033[1;33m"
  else
    NOCOLOR_FLAG=" --nocolor"
  fi
}

print_error(){
  printf "${LRED}error: ${DEFA}${1}"
  printf "\n"
  exit 1
}

print_warning(){
  printf "${YELL}warning: ${DEFA}${1}"
  printf "\n"
}

get_pkg_repo(){
    pkgrepo=`LC_ALL=C pacman -Si ${1} 2> /dev/null \
        | grep -m1 Repository | awk -F": " '{print $2}'`
    case ${pkgrepo} in
        core) ;;
        extra) ;;
        testing) ;;
        community) ;;
        community-testing) ;;
        *) pkgrepo="aur" ;;
    esac
}

build_pkg(){
  local pkgname=${1}
  local packageinfo=`tar -tf "${WORKSPACE}/${REPO}.db.tar.gz" | grep -vE 'desc$|depends$' | sed -e 's:\/$::g' | grep '^'${pkgname}'-[0-9]$*'`
  local repopkgver="0-0"
  if [ ! -z ${packageinfo} ]; then
    repopkgver=$(echo ${packageinfo} | awk -F"-" '{print $(NF - 1)}')-$(echo ${packageinfo} | awk -F"-" '{print $NF}')
    local pkgvcs=$(echo ${packageinfo} | awk -F"-" '{print $(NF - 2)}')
  fi
  [ "${pkgvcs}" == "git" -o "${pkgvcs}" == "svn" -o "${pkgvcs}" == "cvs" -o "${pkgvcs}" == "hg" -o "${pkgvcs}" == "darcs" ] && FORCE="true";

  if [ ${NOCONFIRM} != "true" ]; then
    [ "${EDIT}" == "true" ] && edit_pkgbuild ${pkgname}
  fi
  
  cd ${WORKSPACE}/pkgs/${pkgname}
  source PKGBUILD
  packagever=${pkgver}-${pkgrel}

  if [ $(vercmp ${packagever} ${repopkgver}) -gt 0 -o "$FORCE" == "true" ]; then
    if [ "${arch[0]}" == "any" ]; then
      arch="any"
    else
      arch="${CARCH}"
    fi
    if [ ! -f ${WORKSPACE}/${pkgname}-${packagever}-${arch}${PKGEXT} -o "$NOBUILD" != "true" ]; then
      [ ${UID} -eq 0 ] && MAKEPKG_OPTS="${MAKEPKG_OPTS} --asroot"
      if [ "${VERBOSE}" == "true" ]; then
        makepkg ${MAKEPKG_OPTS} || print_warning "makepkg failed!"
        printf "\n"
      else
        makepkg ${MAKEPKG_OPTS} &>/dev/null || print_warning "makepkg failed!"
      fi

      # read the new pkgver for VCS packages
      if [ "${pkgvcs}" == "git" -o "${pkgvcs}" == "svn" -o "${pkgvcs}" == "cvs" -o "${pkgvcs}" == "hg" -o "${pkgvcs}" == "darcs" ]; then
        source PKGBUILD
        packagever=${pkgver}-${pkgrel}
      fi
      
      if [ -f ${WORKSPACE}/pkgs/${pkgname}/${pkgname}-${packagever}-${arch}${PKGEXT} ]; then
        cp ${WORKSPACE}/pkgs/${pkgname}/${pkgname}-${packagever}-${arch}${PKGEXT} ${WORKSPACE}/ &>/dev/null
        printf "${LGRE}done${DEFA}\n"
        built="${built} ${pkgname}-${packagever}-${arch}${PKGEXT}"
      fi
    else
      printf "${LGRE}done${DEFA}, found in ${WORKSPACE}\n"
      built="${built} ${pkgname}-${packagever}-${arch}${PKGEXT}"
    fi
  else
    printf "already up-to-date\n"
  fi
}

update(){
  if [ "${NOCHANGELOG}" != "true" ]; then
    [ -f /tmp/${basename} ] && rm -rf /tmp/${basename}
    mkdir /tmp/${basename}
    if [ "${ADD}" == "true" ]; then
      for pkg in ${built}; do
        echo "* `date +\"%d-%m-%Y %R\"` `whoami` ${pkg}" >> /tmp/${basename}/header
      done
    fi
    if [ "${REMOVE}" == "true" ]; then
      for pkg in ${packages}; do
        echo "* `date +\"%d-%m-%Y %R\"` `whoami` ${pkg} REMOVED" >> /tmp/${basename}/header
      done
    fi
    cat /tmp/${basename}/header "${WORKSPACE}/${CHANGELOG}" > "/tmp/${basename}/${CHANGELOG}"
    mv "/tmp/${basename}/${CHANGELOG}" "${WORKSPACE}/${CHANGELOG}"
  fi
    
  if [ "${ADD}" == "true" ]; then
    pushd "${WORKSPACE}" &>/dev/null
    if [ "${VERBOSE}" == "true" ]; then
       repo-add "${REPO}.db.tar.gz" ${built} || print_error "repo-add error"
    else
      repo-add "${REPO}.db.tar.gz" ${built} &>/dev/null || print_error "repo-add error"
    fi
    popd &>/dev/null
  elif [ "${REMOVE}" == "true" ]; then
     if [ "${VERBOSE}" == "true" ]; then
      repo-remove "${WORKSPACE}/${REPO}.db.tar.gz" ${packages} || print_error "repo-remove error"
    else
      repo-remove "${WORKSPACE}/${REPO}.db.tar.gz" ${packages} &>/dev/null || print_error "repo-remove error"
    fi
  fi
  printf "${LGRE}done${DEFA}\n"
}

usage(){
  printf "A tool to manage your personal Arch Linux repository\n"
  printf "Usage: ${basename} <action>|<flag> [OPTIONS] packages\n"
  printf "\n"
  printf "Action:\n"
  printf "  -S, --add <pkg>    add or update packages on repository\n"
  printf "  -R, --remove <pkg> remove packages from repository\n"
  printf "Flag:\n"
  printf "      --all          update the whole repository\n"
  printf "      --clean        remove any files from workspace dir\n"
  printf "Options:\n"
  printf "  -b, --nobuild      do not build packages if exist in workspace dir\n"
  printf "  -e, --noextract    do not extract source files (use existing pkgs/src/ dir)\n"
  printf "  -f, --force        build packages if already on repo\n"
  printf "  -l, --log          enable makepkg to log package build process\n"
  printf "  -u, --noupload     do not upload any file to ftp\n"
  printf "      --nochangelog  do not use a changelog file\n"
  printf "      --noconfirm    do not ask\n"
  printf "      --noedit       do not ask to edit pkgbuild for each package\n"
  printf "      --nocolor      do not use any color\n"
  printf "  -v, --verbose      more verbose, print commands output\n"
  printf "      --help         display this help and exit\n"
}

check_args(){
  ADD="false"
  REMOVE="false"
  ALL="false"
  EDIT="true"
  FORCE="false"
  LOG="false"
  NOEXTRACT="false"
  NOUPLOAD="false"
  NOBUILD="false"
  NOCHANGELOG="false"
  NOCOLOR="false"
  NOCONFIRM="false"
  VERBOSE="false"
  
  MAKEPKG_OPTS="-f --noconfirm"
  
  if [ -f ${HOME}/.repoman.conf ]; then
    source "${HOME}/.repoman.conf"
  else
    source "/etc/repoman.conf"
  fi
  source /etc/makepkg.conf
  [ -f ${HOME}/.makepkg.conf ] && source ${HOME}/.makepkg.conf
  
  if [ "$#" -eq "0" ]; then
    usage
    exit 1
  fi

  while [ "$#" -ne "0" ]; do
    OPTIND=0
    for EXTRA_FLAG in $@; do
      case ${EXTRA_FLAG} in
        -*) break ;;
         *) packages="${packages} ${EXTRA_FLAG}"; shift ;;
      esac
    done
    while getopts ":RSbefluv:-:" ARGS; do
      case ${ARGS} in
        R) REMOVE="true";;
        S) ADD="true" ;;
        b) NOBUILD="true" ;;
        e) MAKEPKG_OPTS="${MAKEPKG_OPTS} -e" ;;
        f) FORCE="true" ;;
        l) MAKEPKG_OPTS="${MAKEPKG_OPTS} -L" ;;
        u) NOUPLOAD="true" ;;
        v) VERBOSE="true" ;;
        -) 
        case ${OPTARG} in
          add) ADD="true" ;;
          remove) REMOVE="true";;
          all) ALL="true"; ADD="true" ;;
          force) FORCE="true" ;;
          log) MAKEPKG_OPTS="${MAKEPKG_OPTS} -L" ;;
          noedit) EDIT="false" ;;
          noextract) MAKEPKG_OPTS="${MAKEPKG_OPTS} -e" ;;
          noupload) NOUPLOAD="true" ;;
          nobuild) NOBUILD="true" ;;
          nochangelog) NOCHANGELOG="true" ;;
          nocolor) NOCOLOR="true"; MAKEPKG_OPTS="${MAKEPKG_OPTS} --nocolor" ;;
          noconfirm) NOCONFIRM="true" ;;
          verbose) VERBOSE="true" ;;
          clean) clean; exit 0 ;;
          help) usage; exit 0 ;;
          *) usage; exit 1 ;;
        esac ;;
        ?) usage; exit 1 ;;
      esac
    done
    shift $(($OPTIND - 1))
  done
}

edit_pkgbuild(){
  local pkgname=${1}
  if [ -f "${WORKSPACE}/pkgs/${pkgname}/PKGBUILD" ]; then
    printf "${BOLD}edit PKGBUILD? (Y/n): "
    read EDIT_ANSWER
    if [ "$EDIT_ANSWER" != "n" ]; then
      [ -z "$EDITOR" ] && EDITOR="nano"
      $EDITOR "${WORKSPACE}/pkgs/${pkgname}/PKGBUILD"
    fi
  fi
}

get_pkg_from_aur(){
  local pkgname=${1}
  if [ "${VERBOSE}" == "true" ]; then
    wget -P "${WORKSPACE}/pkgs" http://aur.archlinux.org/packages/${pkgname}/${pkgname}.tar.gz || print_warning "not found in AUR"
    printf "\n"
  else
    wget -P "${WORKSPACE}/pkgs" http://aur.archlinux.org/packages/${pkgname}/${pkgname}.tar.gz &>/dev/null || print_warning "not found in AUR"
  fi
}

extract_pkg(){
  local pkgname=${1}
  if [ "${VERBOSE}" == "true" ]; then
    tar -xf "${WORKSPACE}/pkgs/${pkgname}.tar.gz" -C "${WORKSPACE}/pkgs" || print_warning "source-only tarball not found"
    printf "\n"
  else
    tar -xf "${WORKSPACE}/pkgs/${pkgname}.tar.gz" -C "${WORKSPACE}/pkgs" &>/dev/null || print_warning "source-only tarball not found"
  fi
}

get_pkgbuild(){
  local pkgname=${1}
  if [ ! -f ${WORKSPACE}/pkgs/${pkgname}/PKGBUILD ]; then
    get_pkg_repo ${pkgname}
    if [ "${pkgrepo}" != "aur" ]; then
      if [ "${VERBOSE}" == "true" ]; then
        rsync -mrtv --no-motd --delete-after --delete-excluded rsync.archlinux.org::abs/{${CARCH},any}/${pkgrepo}/${pkgname} "${WORKSPACE}/pkgs" || print_warning "rsync error"
        printf "\n"
      else
        rsync -mrtv --no-motd --delete-after --delete-excluded rsync.archlinux.org::abs/{${CARCH},any}/${pkgrepo}/${pkgname} "${WORKSPACE}/pkgs" &>/dev/null || print_warning "rsync error"
      fi
    elif [ "${pkgrepo}" == "aur" ]; then
      get_pkg_from_aur ${pkgname}
      extract_pkg ${pkgname}
    fi
  fi
  printf "${LGRE}done${DEFA}\n"
}

ask_remove(){
  printf "${BOLD}Do you want to clean packages build dirs? (y/N): ${DEFA}"
  read DIR_REMOVE
  if [ "$DIR_REMOVE" == "y" ]; then
    rm -rf ${WORKSPACE}/pkgs/*/{pkg/,src/,*.pkg.tar.*}
  fi
}

clean(){
  rm -rf "${WORKSPACE}" /tmp/${basename} &>/dev/null
  printf "${BOLD}Any files in workspace directory have been removed\n${DEFA}"
}

cleanup_ftp(){
  files=""
  if [ "${REMOVE}" == "true" ]; then
    for pkg in ${packages}; do
      local packageinfo=`tar -tf "${WORKSPACE}/${REPO}.db.tar.gz.old" | grep -vE 'desc$|depends$' | sed -e 's:\/$::g' | grep '^'${pkg}'-[0-9]$*'`
      files="${files} ${packageinfo}-*.pkg.tar.*"
    done
  elif [ "${ADD}" == "true" ]; then
    for pkg in ${built}; do
      local packageinfo=`tar -tf "${WORKSPACE}/${REPO}.db.tar.gz.old" | grep -vE 'desc$|depends$' | sed -e 's:\/$::g' | grep '^'${pkg}'-[0-9]$*'`
      files="${files} ${packageinfo}-*.pkg.tar.*"
    done
  fi
  if [ "${VERBOSE}" == "true" ]; then
    lftp -u "${USERNAME},${PASSWORD}" -e "${LFTP_CMDS}; glob rm -f ${files}; exit" "${FTP_URL}/${FTP_DIR}" || print_warning "cannot remove files from FTP"
    printf "\n"
  else
    lftp -u "${USERNAME},${PASSWORD}" -e "${LFTP_CMDS}; glob rm -f ${files}; exit" &>/dev/null "${FTP_URL}/${FTP_DIR}" || print_warning "cannot remove files from FTP"
  fi
  printf "${LGRE}done${DEFA}\n"
}

upload(){
  files="${REPO}.db.tar.gz"
  [ ! ${NOCHANGELOG} ] && files="${files} ${CHANGELOG}"
    
  if [ "${ADD}" == "true" ]; then
    for pkg in ${built}; do
      files="${files} ${pkg}"

    done
  fi
  pushd ${WORKSPACE} &>/dev/null
  if [ "${VERBOSE}" == "true" ]; then
    lftp -u ${USERNAME},"${PASSWORD}" -e "${LFTP_CMDS}; put ${files}; exit" "${FTP_URL}/${FTP_DIR}" || print_error "upload failed"
  else
    lftp -u ${USERNAME},"${PASSWORD}" -e "${LFTP_CMDS}; put ${files}; exit" "${FTP_URL}/${FTP_DIR}" &>/dev/null || print_error "upload failed"
  fi
  popd &>/dev/null
  printf "${LGRE}done${DEFA}\n"
}

get_pkgs_list(){
  for package in `tar -tf "${WORKSPACE}/${REPO}.db.tar.gz" | grep -vE 'desc$|depends$' | sed -e 's:\/$::g'`; do
    local pkgname=$(echo ${package} | awk -F"-" '{for (i=1; i<NF - 2; i++) printf "%s-", $i; printf $(NF - 2)"\n" }')
    packages="${packages} ${pkgname}"
  done
}

check_files(){
  if [ ! -d "${WORKSPACE}/pkgs" ]; then
    mkdir -p "${WORKSPACE}/pkgs" || print_error "cannot create ${WORKSPACE}/pkgs/"
  fi
  if [ "${NOCHANGELOG}" != "true" ]; then
    touch "${WORKSPACE}/${CHANGELOG}" || print_error "cannot create ${CHANGELOG}"
  fi
}

main(){
  check_args $@
  colors
  check_files

  if [ "${NOCHANGELOG}" != "true" ]; then
    printf "Downloading ${BOLD}${CHANGELOG}${DEFA}\n"
    mv "${WORKSPACE}/${CHANGELOG}" "${WORKSPACE}/${CHANGELOG}.old" &>/dev/null
    if [ "${VERBOSE}" == "true" ]; then
      wget -P "${WORKSPACE}" "${URL}/${CHANGELOG}" || print_error "unable to get ${CHANGELOG}"
      print "\n"
    else  
      wget -P "${WORKSPACE}" "${URL}/${CHANGELOG}" &>/dev/null || print_error "unable to get ${CHANGELOG}"
    fi
  fi
  printf "Downloading ${BOLD}${REPO}.db.tar.gz${DEFA}\n"
  mv "${WORKSPACE}/${REPO}.db.tar.gz" "${WORKSPACE}/${REPO}.db.tar.gz.old" &>/dev/null
  if [ "${VERBOSE}" == "true" ]; then
    wget -P "${WORKSPACE}" "${URL}/${REPO}.db.tar.gz" || print_error "unable to get ${REPO}.db.tar.gz"
    print "\n"
  else
    wget -P "${WORKSPACE}" "${URL}/${REPO}.db.tar.gz" &>/dev/null || print_error "unable to get ${REPO}.db.tar.gz"
  fi

  [ "${ALL}" == "true" ] && get_pkgs_list

  if [ ! -z ${#packages} ]; then
    printf "Packages:${BOLD}${packages}${DEFA}\n"
  else
    printf "None package\n\n"
    exit 0
  fi

  if [ "${ADD}" != "true" -a "${REMOVE}" != "true" ]; then
    printf "${YELL}What I must do with these packages?!${DEFA}\n\n"
    exit 0
  fi

  if [ "${ADD}" == "true" ]; then
    for pkg in ${packages}; do
      printf "Getting ${BOLD}${pkg}${DEFA} PKGBUILD..."
      get_pkgbuild ${pkg}
      printf "Building ${BOLD}${pkg}${DEFA}..."
      build_pkg ${pkg}
    done
  fi

  if [ ${#built} -gt 0 ] || [ "${REMOVE}" == "true" ]; then
    printf "Updating ${BOLD}${CHANGELOG}${DEFA} and ${BOLD}${REPO}.db.tar.gz${DEFA}..."
    update

    printf "Uploading files..."
    [ "${NOUPLOAD}" != "true" ] && upload

    printf "Cleanup ftp..."
    cleanup_ftp

    if [ ${NOCONFIRM} != "true" ]; then
      [ "${ADD}" == "true" ] && ask_remove
    fi
  fi
}

main $@

exit 0
